# Beschreibung eines Psi-Dokumentes

#!
 ! Mehrzeiliger Kommentar wird mit
 ! '#!' eingeleitet und geht solange,
 ! bis ein '!#' auftritt. Alles dazwischen
 ! wird ignoriert. (Dieser Kommentar ist kaputt!
 !#

# Einzeilige Kommentare werden mit einem
# '#' eingeleitet.

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Kapitel: Deklarationen                                                    !
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#

# Es gibt drei Formen der Variablendeklaration:
var foo : type;        # Uninitialisiert
var foo = expr;        # Deduziert und initialisiert
var foo : type = expr; # Definiert und initialisiert

# und zwei Formen der Konstantendeklaration
const foo = expr;        # Konstante deduziert
const foo : type = expr; # Konstante explizit

# Zusätzlich zu Variablen und Konstanten können neue Typen
# angelegt werden und bereits vorhandene Typen kopiert werden:

type zahl = int;      # Umbennenung
type bit  = int<0,1>; # Instanzierung
type time = record(hour : int, minute : int); # Neudefinition

# Es kann auch benutzerdefinierte Operatoren geben,
# diese dürfen nur aus Zeichen bestehen, welche die ctype
# Bedingung `isprint(c) && !isalnum(c) && !isspace(c)`
# erfüllt, also alle sichtbaren Zeichen, die keine Buchstaben,
# Zahlen und '_' enthalten. Zudem dürfen Operatoren nicht
# die Sprachnotwendigen Operatoren '.' und '\'' sein.
# Operatoren können unär (prefix) oder binär (infix) sein.

# Example 1: String trimming
	unary operator '~' = fn(str : string) → string
	{
		return std.trim(str);
	};
	# Now it is possible to trim a string by prepending ~
	var trimmed = ~" ↤     ↦    ";

# Example 2: String repetition
	binary operator '*' = fn(str : string, count : int) → string
	{
		var res = ""; # Implicit type
		# -> is a range operator and returns an iteratables
		for(i in 1 -> count) {
			res = res .. str;
		}
		return res;
	};



# Es gibt Module (ähnlich Namespace in C#)
module foo
{
	# Hier kann wieder ein beliebiges Dokument stehen,
	# in dem alles in das Modul 'foo' exportiert wird
}

# Module können geschachtelt sein, da in einem Modul
# wieder ein Dokument steht:
module foo
{
	module bar
	{
		# Hier gilt das selbe wie oben
	}
}

# Hierfür kann ein Shorthand eingefügt werden:
module foo.bar
{
	# Hier gilt das selbe wie oben
}

# In einem Modul kann ein Import durchgeführt werden,
# welcher die Member eines Moduls in den aktuellen
# Scope importiert
import foo.bar; # Importiert das gesamte Modul
import foo.bar.member; # importiert einen einzelnen Member
import foo.bar as baz; # Benennt ein Modul lokal um
import foo.bar.member as bam; # Importiert einen umbenannten Member

# Generische Deklarationen werden mit dem Schlüsselwort 'generic'
# eingeleitet. Hierbei können nur Variablen, Konstanten und Typen
# als generisch deklariert werden, Module dürfen nicht generisch sein.

generic type positive_int<max : int> = int<1, max>;

# Member eines Moduls sind privat, solange sie nicht als 'export'
# markiert werden. Nur exportierte Member werden durch 'import'
# in ein anderes Modul eingefügt.
# Exportiert werden können Variablen, Konstanten, Typen und generische
# Varianten dieser
export var foo : int;
export const bar = 10;
export type num = int;

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Kapitel: Typsystem                                                        !
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#

# SIEHE types.md!

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Kapitel: Ausdrücke                                                        !
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#

# Arrayliteral:
var arr = [ 1, 2, 3, 4 ];

# Operatoren:
#!
-- Stärkste Bindung
 **
 * / %
 + - .. (Binäre Operatoren)
 > >= < <=
 == !=
 & | ^ -> (Implies)
 = += -= *= /= %= &= |= ..=
-- Schwächste Bindung
!#



#!
 Jeder Typ besitzt folgende Operatoren:
 = assignment
 
 Für numerische Typen werden die Standardoperatoren bereitgestellt:
 -  unary minus, negates
 +  addition
 -  subtraction
 *  multiplication
 /  division
 %  modulo division
 ** exponentiation
 >= mequal
 <= lequal
 >  more than
 <  less than
 == equality
 != inequality
 
 Zusätzlich werden für Integer-Typen
 folgende Standardoperatoren bereitgestellt:
 &  binary and
 |  binary or
 ~  binary not
 ^  binary xor

 String-Operatoren:
 -- concatenation
 ** repetition (string^int -> string repeated int times)
 
 Boolean-Operatoren:
 &  logic and
 |  logic or
 ~  logic not
 ^  logic xor
 -> logic implication
 
!#