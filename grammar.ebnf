################################################################################
# Ïˆlang Grammar                                                                #
################################################################################

# Short explanation of the grammer notation used here:
# rule := contents;
# contents can be
# - a sequence (separated by space)
# - an option (separated by '|')
# - a [1;n] repetition (enclosed in '{}')
# - a token ('$\S+')
# - an implicit token ("text")
# - an optional (enclosed in '[]')
# - a grouping (enclosed in '()')

document     := { <declaration> | <module> };

module       := "module" $ident "{" <document> "}";

declaration  := <typedecl> | <vardecl> | <gendecl>;

# Type declaration
# <genlist> is only valid when having a generic declaration,
# else syntax error (by semantic part)
typedecl     := "type" $ident "=" <type> ";";

# Variable declaration
# <genlist> is only valid when having a generic declaration,
# else syntax error (by semantic part)
vardecl      := [ "const" ] "var" $ident ( ":" <type> | ":" <type> "=" <expression> | "=" <expression> ] ";";

# Generic declaration
gendecl      := "generic" ( <gentypedecl> | <genvardecl> );
gentypedecl  := "type" $ident <genlist> "=" <type> ";";
vardecl      := [ "const" ] "var" $ident <genlist> ( ":" <type> | ":" <type> "=" <expression> | "=" <expression> ] ";";

# List of generic parameters enclosed by '<>'
genlist      := "<" <genlist_iter> ">";
genlist_iter := $ident ":" $type [ "," <genlist_iter> ];

# A type literal
# with options record, named type, named type with generic list
type         := <type_record> | $ident | $ident "<" <exprlist> ">";

type_record  := "record" "(" <reclist> ")";

reclist      := $ident ":" <type> [ "=" <expression> ] [ "," <reclist> ];

exprlist     := <expression> [ "," <exprlist> ];

# expression  := <literal> | 