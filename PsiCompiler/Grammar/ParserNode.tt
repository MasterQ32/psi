<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)/CompilerKit/bin/Debug/CompilerKit.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var list = new Dictionary<string,string>();
	
	list.Add("Token<PsiTokenType>", "Token");
	list.Add("Expression", "Expression");
	list.Add("Module", "Module");
	list.Add("Assertion", "Assertion");
	list.Add("CompoundName", "Name");
	list.Add("Declaration", "Declaration");
	list.Add("bool?", "Boolean");
	list.Add("PsiOperator?", "Operator");
	list.Add("string", "String");


#>
using System;
using CompilerKit;

namespace PsiCompiler.Grammar
{
	public struct ParserNode
	{
<#	foreach(var f in list)
	{
#>		private <#=f.Key#> <#="_"+f.Value#>;
<#	}
	foreach(var f in list)
	{
#>		
		public ParserNode(<#=f.Key#> value)
		{
<#	foreach(var o in list) {
		if(o.Key == f.Key) {
#>			this.<#="_"+o.Value#> = value.NotNull();
<#		} else {
#>			this.<#="_"+o.Value#> = null;
<#		}
	}
#>
		}
<#	}
	foreach(var f in list)
	{
#>		
		public <#=f.Key#> <#=f.Value#>
		{
			get
			{
				if(this.<#="_"+f.Value#> == null)
					throw new InvalidOperationException("ParserNode is not a <#=f.Value#>");
				return this.<#="_"+f.Value#>;
			}
			set
			{
<#		foreach(var o in list) {
			if(o.Key == f.Key) {
#>				this.<#="_"+o.Value#> = value;
<#			} else {
#>				this.<#="_"+o.Value#> = null;
<#			}
		}
#>
			}
		}
<#	}
	foreach(var f in list)
	{
#>		
		public static implicit operator ParserNode(<#=f.Key#> value) => new ParserNode(value);
<#	}
#>
		
		public override string ToString()
		{
<#
	foreach(var f in list)
	{
#>			if(this.<#="_"+f.Value#> != null)
				return "Node(<#=f.Value#>): " + <#="_"+f.Value#>.ToString();
<#	}
#>
			return "<???>";
		}
	}
}
