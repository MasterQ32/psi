/*****************************************************************************
* Compiler Test Program                                                      *
*****************************************************************************/

import std;

var x : fn(i : int);

var x : fn(this j : int); // same as other "x"


/*
var foo : int = 10;

var bar : int = foo;

var v0 : person;
var v1 : record(x : string, y : int) = v0;

*/

/*
// Tests 'out' params
const set = fn(out dst : int, src : int) { dst = src; };

// Tests return values
const limit = fn() -> int { return 38; }

// Tests closures and flow control
const main = fn()
{
	var i : int;
	set(i, 42);
	
	while(i > limit())
	{
		i = i - 1;
	}

	const print = fn() 
	{
		print("i = ");
		print(i);
		print("\n");
	};

	print();
};
*/

/*


// TODO: Implement support for complex compound names
// module submodule.inception { }

import std;
type myint = int; // requires "import std;"

type stringlist = array<string>;
type matrix = array<std.int, 2>;

type fwdref = gender;

type gender = enum(none,male,female,ah64);

type builtin = std.int;

type backref = gender;

type person = record
(
	age    : std.int,
	name   : std.string,
	gender : gender
);

type recursive = record
	(
		age : int,
		next : recursive
	);

// tests dependencies
type bam = bar;

type baz = bam;

type foo = std.int;

type bar = foo;

type someType = std.compiler.type;

type family = array<foo>;

type someone = ref<person>;

type bunchOfPeople = array<ref<person> >;

type mainFunc = fn(argc : int, argv : array<string>) -> int;

*/

/*
lexical scope test

type a = std.int;

module submodule
{
	type b = a;

	module inception
	{
		type c = a;
		type d1 = b;
		type d2 = submodule.b;
		type e1 = c;
		type e2 = submodule.inception.c;
	}
}
*/